import { Injectable } from '@nestjs/common';
import { IndexerInterface } from './indexer.interface';
import { XexchangeIndexer } from './implementations/xexchange.indexer';
import { PostgresIndexerService } from './postgres/postgres.indexer.service';
import { ElasticIndexerService } from './elastic/elastic.indexer.service';

@Injectable()
export class IndexerService {
  constructor(
    private readonly postgresIndexerService: PostgresIndexerService,
    private readonly elasticIndexerService: ElasticIndexerService,
  ) {}

  getIndexer(name: string): IndexerInterface | undefined {
    switch (name) {
      case 'xexchange':
        return new XexchangeIndexer();
    }

    return undefined;
  }

  async indexInterval(_start: Date, _end: Date, _indexer: IndexerInterface) {
    // TODO:
    // - delete from the database all rows for the given indexer
    await this.postgresIndexerService.clear();
    // - fetch all logs between start and end emitted by the given contracts using elastisearch
    // - search by events.identifier nested query and look for swapTokensFixedInput & swapTokensFixedOutput
    const logsSwapToken = await this.elasticIndexerService.getSwapTokenLogs(
      _start,
      _end,
    );

    const logsEvents = logsSwapToken.map((log) => log.events);

    const decodedEvents = await Promise.all(
      logsEvents
        .flat()
        .map(async (event: { identifier: string; topics: string[] }) => {
          return {
            identifier: event.identifier,
            topics: await this.elasticIndexerService.topicDecoder(
              event.identifier,
              event.topics,
            ),
          };
        }),
    );

    // match logsSwapTokensFixedInput with logsSwapTokensFixedOutput based on address ?

    // Decode data logs and tokens used?
    // Volume?
    // Map addres to token?

    // QueryType.Nested('events', { 'events.identifier': 'swapTokensFixedInput' })

    // - all prices will be in egld
    // - find all swaps transactions
    // - decode the logs (4 transactions - 2 swapFixedInput & 2 swapFixedOutput)
    // -look into data field
    // -get values from esdt transfer for fixedInput
    // -get esdt transfer from contract to wallet and reverse (be careful for the fee)
    // -volume will be generated by sum of wrapped egld
    //  - use can use ElasticService for this
    // - populate the database with the results
    // - take into account the fee calculated by:
    // - Usdc to egld will be -0.3% fee (divide by 1-tax) e.g for example tva brut & net by multiplication
    // - call getPairChange that should decode the swapTokensFixedInput & swapTokensFixedOutput events for now
    // - insert the results in the database
    //   - the table structure should be the following;
    //     - exchange: string
    //     - pair: string
    //     - price: number
    //     - volume: number
    //     - fee: number (populate with 0 for now)
    //     - timestamp: number
    // decoding address: (AAAAAAAAAAAFAAa0axUJHXMOXzuMh8PpyKXYGMe6VIM=)
    // AddressUtils.bech32Encode(BinaryUtils.base64ToHex('AAAAAAAAAAAFAAa0axUJHXMOXzuMh8PpyKXYGMe6VIM='))

    return {
      decodedEvents,
      raw: logsSwapToken,
    };
  }
}
